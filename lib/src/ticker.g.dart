// 
// Generated file. Do not edit manually.
// 
// Copyright (C) 2022 Plague Fox
// Unauthorized copying of this project, via any medium is strictly prohibited
// Proprietary and confidential
// Written by Plague Fox <plugfox@gmail.dev>, 2022
// 
// Flutter calling into Android Steps:
// 1) Add Pigeon as a dev_dependency.
// 2) Make a ".dart" file outside of your "lib" directory for defining the communication interface.
// 3) Run pigeon on your ".dart" file to generate the required Dart and Java code. flutter pub get then flutter pub run pigeon with suitable arguments.
// 4) Add the generated Dart code to ./lib for compilation.
// 5) Add the generated Java code to your ./android/app/src/main/java directory for compilation.
// 6) Implement the generated Java interface for handling the calls on Android, set it up as the handler for the messages.
// 7) Call the generated Dart methods.
// 
// Rules for defining your communication interface:
// 1) The file should contain no method or function definitions, only declarations.
// 2) Datatypes are defined as classes with fields of the supported datatypes (see the supported Datatypes section).
// 3) Api's should be defined as an abstract class with either HostApi() or FlutterApi() as metadata. The former being for procedures that are defined on the host platform and the latter for procedures that are defined in Dart.
// 4) Method declarations on the Api classes should have one argument and a return value whose types are defined in the file or be void.
// 
// Platform channel data types support and codecs:
// + https://flutter.dev/docs/development/platform-integration/platform-channels#codec
// Autogenerated from Pigeon (v1.0.12), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

class TickerDelay {
  int? delay;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['delay'] = delay;
    return pigeonMap;
  }

  static TickerDelay decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TickerDelay()
      ..delay = pigeonMap['delay'] as int?;
  }
}

class TickerResult {
  bool? successful;
  bool? hasError;
  String? error;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['successful'] = successful;
    pigeonMap['hasError'] = hasError;
    pigeonMap['error'] = error;
    return pigeonMap;
  }

  static TickerResult decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TickerResult()
      ..successful = pigeonMap['successful'] as bool?
      ..hasError = pigeonMap['hasError'] as bool?
      ..error = pigeonMap['error'] as String?;
  }
}

class TickerMessage {
  int? timestamp;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['timestamp'] = timestamp;
    return pigeonMap;
  }

  static TickerMessage decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return TickerMessage()
      ..timestamp = pigeonMap['timestamp'] as int?;
  }
}

class _TickerSenderCodec extends StandardMessageCodec {
  const _TickerSenderCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is TickerDelay) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is TickerResult) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return TickerDelay.decode(readValue(buffer)!);
      
      case 129:       
        return TickerResult.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class TickerSender {
  /// Constructor for [TickerSender].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  TickerSender({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _TickerSenderCodec();

  Future<TickerResult> start(TickerDelay arg_tickerDelay) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TickerSender.start', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object>[arg_tickerDelay]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as TickerResult?)!;
    }
  }

  Future<TickerResult> stop() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TickerSender.stop', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
        details: null,
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as TickerResult?)!;
    }
  }
}

class _TickerReceiverCodec extends StandardMessageCodec {
  const _TickerReceiverCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is TickerMessage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return TickerMessage.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}
abstract class TickerReceiver {
  static const MessageCodec<Object?> codec = _TickerReceiverCodec();

  void onTick(TickerMessage tickerMessage);
  static void setup(TickerReceiver? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.TickerReceiver.onTick', codec, binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null, 'Argument for dev.flutter.pigeon.TickerReceiver.onTick was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final TickerMessage? arg_tickerMessage = (args[0] as TickerMessage?);
          assert(arg_tickerMessage != null, 'Argument for dev.flutter.pigeon.TickerReceiver.onTick was null, expected non-null TickerMessage.');
          api.onTick(arg_tickerMessage!);
          return;
        });
      }
    }
  }
}
