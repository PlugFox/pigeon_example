// 
// Generated file. Do not edit manually.
// 
// Copyright (C) 2022 Plague Fox
// Unauthorized copying of this project, via any medium is strictly prohibited
// Proprietary and confidential
// Written by Plague Fox <plugfox@gmail.dev>, 2022
// 
// Flutter calling into Android Steps:
// 1) Add Pigeon as a dev_dependency.
// 2) Make a ".dart" file outside of your "lib" directory for defining the communication interface.
// 3) Run pigeon on your ".dart" file to generate the required Dart and Java code. flutter pub get then flutter pub run pigeon with suitable arguments.
// 4) Add the generated Dart code to ./lib for compilation.
// 5) Add the generated Java code to your ./android/app/src/main/java directory for compilation.
// 6) Implement the generated Java interface for handling the calls on Android, set it up as the handler for the messages.
// 7) Call the generated Dart methods.
// 
// Rules for defining your communication interface:
// 1) The file should contain no method or function definitions, only declarations.
// 2) Datatypes are defined as classes with fields of the supported datatypes (see the supported Datatypes section).
// 3) Api's should be defined as an abstract class with either HostApi() or FlutterApi() as metadata. The former being for procedures that are defined on the host platform and the latter for procedures that are defined in Dart.
// 4) Method declarations on the Api classes should have one argument and a return value whose types are defined in the file or be void.
// 
// Platform channel data types support and codecs:
// + https://flutter.dev/docs/development/platform-integration/platform-channels#codec
// Autogenerated from Pigeon (v1.0.14), do not edit directly.
// See also: https://pub.dev/packages/pigeon
#import "Ticker.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSDictionary<NSString *, id> *wrapResult(id result, FlutterError *error) {
  NSDictionary *errorDict = (NSDictionary *)[NSNull null];
  if (error) {
    errorDict = @{
        @"code": (error.code ? error.code : [NSNull null]),
        @"message": (error.message ? error.message : [NSNull null]),
        @"details": (error.details ? error.details : [NSNull null]),
        };
  }
  return @{
      @"result": (result ? result : [NSNull null]),
      @"error": errorDict,
      };
}

@interface TickerDelay ()
+ (TickerDelay *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface TickerResult ()
+ (TickerResult *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end
@interface TickerMessage ()
+ (TickerMessage *)fromMap:(NSDictionary *)dict;
- (NSDictionary *)toMap;
@end

@implementation TickerDelay
+ (TickerDelay *)fromMap:(NSDictionary *)dict {
  TickerDelay *result = [[TickerDelay alloc] init];
  result.delay = dict[@"delay"];
  if ((NSNull *)result.delay == [NSNull null]) {
    result.delay = nil;
  }
  return result;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.delay ? self.delay : [NSNull null]), @"delay", nil];
}
@end

@implementation TickerResult
+ (TickerResult *)fromMap:(NSDictionary *)dict {
  TickerResult *result = [[TickerResult alloc] init];
  result.successful = dict[@"successful"];
  if ((NSNull *)result.successful == [NSNull null]) {
    result.successful = nil;
  }
  result.hasError = dict[@"hasError"];
  if ((NSNull *)result.hasError == [NSNull null]) {
    result.hasError = nil;
  }
  result.error = dict[@"error"];
  if ((NSNull *)result.error == [NSNull null]) {
    result.error = nil;
  }
  return result;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.successful ? self.successful : [NSNull null]), @"successful", (self.hasError ? self.hasError : [NSNull null]), @"hasError", (self.error ? self.error : [NSNull null]), @"error", nil];
}
@end

@implementation TickerMessage
+ (TickerMessage *)fromMap:(NSDictionary *)dict {
  TickerMessage *result = [[TickerMessage alloc] init];
  result.timestamp = dict[@"timestamp"];
  if ((NSNull *)result.timestamp == [NSNull null]) {
    result.timestamp = nil;
  }
  return result;
}
- (NSDictionary *)toMap {
  return [NSDictionary dictionaryWithObjectsAndKeys:(self.timestamp ? self.timestamp : [NSNull null]), @"timestamp", nil];
}
@end

@interface TickerSenderCodecReader : FlutterStandardReader
@end
@implementation TickerSenderCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [TickerDelay fromMap:[self readValue]];
    
    case 129:     
      return [TickerResult fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface TickerSenderCodecWriter : FlutterStandardWriter
@end
@implementation TickerSenderCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[TickerDelay class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
  if ([value isKindOfClass:[TickerResult class]]) {
    [self writeByte:129];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface TickerSenderCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation TickerSenderCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[TickerSenderCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[TickerSenderCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *TickerSenderGetCodec() {
  static dispatch_once_t s_pred = 0;
  static FlutterStandardMessageCodec *s_sharedObject = nil;
  dispatch_once(&s_pred, ^{
    TickerSenderCodecReaderWriter *readerWriter = [[TickerSenderCodecReaderWriter alloc] init];
    s_sharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return s_sharedObject;
}


void TickerSenderSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<TickerSender> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel
        messageChannelWithName:@"dev.flutter.pigeon.TickerSender.start"
        binaryMessenger:binaryMessenger
        codec:TickerSenderGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startTickerDelay:error:)], @"TickerSender api (%@) doesn't respond to @selector(startTickerDelay:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        TickerDelay *arg_tickerDelay = args[0];
        FlutterError *error;
        TickerResult *output = [api startTickerDelay:arg_tickerDelay error:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [FlutterBasicMessageChannel
        messageChannelWithName:@"dev.flutter.pigeon.TickerSender.stop"
        binaryMessenger:binaryMessenger
        codec:TickerSenderGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopWithError:)], @"TickerSender api (%@) doesn't respond to @selector(stopWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        TickerResult *output = [api stopWithError:&error];
        callback(wrapResult(output, error));
      }];
    }
    else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface TickerReceiverCodecReader : FlutterStandardReader
@end
@implementation TickerReceiverCodecReader
- (nullable id)readValueOfType:(UInt8)type 
{
  switch (type) {
    case 128:     
      return [TickerMessage fromMap:[self readValue]];
    
    default:    
      return [super readValueOfType:type];
    
  }
}
@end

@interface TickerReceiverCodecWriter : FlutterStandardWriter
@end
@implementation TickerReceiverCodecWriter
- (void)writeValue:(id)value 
{
  if ([value isKindOfClass:[TickerMessage class]]) {
    [self writeByte:128];
    [self writeValue:[value toMap]];
  } else 
{
    [super writeValue:value];
  }
}
@end

@interface TickerReceiverCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation TickerReceiverCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[TickerReceiverCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[TickerReceiverCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *TickerReceiverGetCodec() {
  static dispatch_once_t s_pred = 0;
  static FlutterStandardMessageCodec *s_sharedObject = nil;
  dispatch_once(&s_pred, ^{
    TickerReceiverCodecReaderWriter *readerWriter = [[TickerReceiverCodecReaderWriter alloc] init];
    s_sharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return s_sharedObject;
}


@interface TickerReceiver ()
@property (nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation TickerReceiver
- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}

- (void)onTickTickerMessage:(TickerMessage *)arg_tickerMessage completion:(void(^)(NSError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.TickerReceiver.onTick"
      binaryMessenger:self.binaryMessenger
      codec:TickerReceiverGetCodec()];
  [channel sendMessage:@[arg_tickerMessage] reply:^(id reply) {
    completion(nil);
  }];
}
@end
